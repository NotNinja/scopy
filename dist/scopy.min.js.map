{"version":3,"file":"scopy.min.js","sources":["../src/scopy.js"],"sourcesContent":["/*\n * Copyright (C) 2017 Alasdair Mercer, !ninja\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n'use strict';\n\n/**\n * Returns a scoped key based on the specified <code>name</code> and using the <code>options</code> provided.\n *\n * If the <code>symbol</code> option is enabled (which it is by default), an ES2015 <code>Symbol</code> will be\n * returned (where supported), otherwise this method will simply return <code>name</code> prefixed with an underscore.\n *\n * <code>Symbols</code> returned by this method will always be unique when called multiple times with the same\n * <code>name</code>, however, string keys will always be exactly the same.\n *\n * This method is ideal when defining a key for a privately scoped property.\n *\n * @example\n * <pre>\n * // user.js\n * var Scopy = require('scopy');\n *\n * var _name = Scopy('name');\n *\n * function User(name) {\n *   this[_name] = name;\n * }\n *\n * User.prototype.getName = function() {\n *   return this[_name];\n * };\n *\n * module.exports = User;\n * </pre>\n * @param {string} name - the name for the scoped key\n * @param {Scopy~Options} [options] - the options to be used (may be <code>null</code>)\n * @return {string|symbol} The scoped key for <code>name</code>.\n * @throws {TypeError} If an attempt is made to instantiate <code>Scopy</code> (e.g. via <code>new</code>).\n * @public\n */\nfunction Scopy(name, options) {\n  if (this instanceof Scopy) {\n    throw new TypeError('Scopy is not a constructor');\n  }\n\n  var factory = getKeyFactory(false, options);\n\n  return factory(name);\n}\n\n/**\n * Returns scoped keys based on the specified <code>names</code> and using the <code>options</code> provided.\n *\n * If the <code>symbol</code> option is enabled (which it is by default), this method will return <code>names</code>\n * mapped to ES2015 <code>Symbols</code> (where supported), otherwise <code>names</code> will simply be mapped to\n * themselves prefixed with an underscore.\n *\n * <code>Symbols</code> included in the mapping returned by this method will always be unique when called multiple times\n * with the same name, however, string keys will always be exactly the same.\n *\n * This method is ideal when defining keys for privately scoped properties.\n *\n * @example\n * <pre>\n * // user.js\n * var Scopy = require('scopy');\n *\n * var keys = Scopy.all([ 'email', 'name' ]);\n *\n * function User(email, name) {\n *   this[keys.email] = email;\n *   this[keys.name] = name;\n * }\n *\n * User.prototype.getEmail = function() {\n *   return this[keys.email];\n * };\n *\n * User.prototype.getName = function() {\n *   return this[keys.name];\n * };\n *\n * module.exports = User;\n * </pre>\n * @param {string[]} [names] - the names for the scoped keys (may be <code>null</code>)\n * @param {Scopy~Options} [options] - the options to be used (may be <code>null</code>)\n * @return {Object.<string, string|symbol>} A mapping containing <code>names</code> and their corresponding scoped keys.\n * @public\n * @static\n * @memberof Scopy\n */\nScopy.all = function(names, options) {\n  names = names || [];\n\n  var factory = getKeyFactory(false, options);\n  var keys = {};\n\n  names.forEach(function(name) {\n    keys[name] = factory(name);\n  });\n\n  return keys;\n};\n\n/**\n * Returns the key/value pairs for all of the specified object's own enumerable properties that are not scoped, in the\n * same order as that provided by a for-in loop.\n *\n * This method returns a multi-dimensional array where each item is an array containing the name and value\n * (<code>[name, value]</code>) of a non-scoped enumerable property.\n *\n * Properties mapped to a <code>Symbol</code> are <b>never</b> included in this method but those mapped to properties\n * whose name is prefixed with an underscore, created when the <code>symbol</code> option has been explicitly disabled,\n * <b>will</b> be included <b>unless</b> the <code>symbol</code> option is explicitly disabled when calling this method.\n *\n * This method is intended to be used just like ES2015's <code>Object.entries</code> method while also supporting cases\n * where <code>Symbols</code> have not been used to scope properties.\n *\n * @example\n * <pre>\n * var Scopy = require('scopy');\n * var uuid = require('uuid/v4');\n *\n * var _generateId = Scopy('generateId');\n * var _id = Scopy('id');\n * var _name = Scopy('name');\n *\n * function User(name) {\n *   this[_id] = this[_generateId]();\n *   this[_name] = name;\n *   this.length = name.length;\n * }\n *\n * User.prototype[_generateId] = function() {\n *   return uuid();\n * };\n *\n * User.prototype.getName = function() {\n *   return this[_name];\n * };\n *\n * Scopy.entries(new User('foo'));\n * //=> [ [ \"length\", 3 ] ]\n * Scopy.entries(User.prototype);\n * //=> [ [ \"getName\", function() { return this[_name] } ] ]\n * </pre>\n * @param {Object} obj - the object whose enumerable own non-scoped property key/value pairs are to be returned\n * @param {Scopy~Options} [options] - the options to be used (may be <code>null</code>)\n * @return {Array} An array containing the key/value pairs for all of the enumerable non-scoped properties of\n * <code>obj</code>.\n * @public\n * @static\n * @memberof Scopy\n */\nScopy.entries = function(obj, options) {\n  return mapProperties(obj, function(value, name) {\n    return [ name, value ];\n  }, options);\n};\n\n/**\n * Returns a \"global\" key based on the specified <code>name</code> and using the <code>options</code> provided.\n *\n * If the <code>symbol</code> option is enabled (which it is by default), an ES2015 <code>Symbol</code> will be returned\n * from the runtime-wide symbol registry (where supported), otherwise this method will simply return <code>name</code>\n * prefixed with an underscore.\n *\n * Unlike {@link Scopy}, <code>Symbols</code> returned by this method will always be the same when called multiple times\n * with the same <code>name</code>, just like string keys.\n *\n * It is recommended that <code>name</code> be prefixed in order to avoid conflicts with other libraries that may also\n * have a \"global\" key of the same name.\n *\n * This method is ideal when defining a key for a protected/internally scoped property.\n *\n * @example\n * <pre>\n * // user.js\n * var Scopy = require('scopy');\n * var uuid = require('uuid/v4');\n *\n * var _id = Scopy.for('example_user_id');\n * var _name = Scopy('name');\n *\n * function User(name) {\n *   this[_id] = uuid();\n *   this[_name] = name;\n * }\n *\n * User.prototype.getName = function() {\n *   return this[_name];\n * };\n *\n * module.exports = User;\n *\n * // user-logger.js\n * var EOL = require('os').EOL;\n * var Scopy = require('scopy');\n *\n * var _id = Scopy.for('example_user_id');\n *\n * exports.login = function(output, user) {\n *   var id = user[_id];\n *\n *   output.write('User[' + id + '] has logged in!' + EOL);\n * };\n * </pre>\n * @param {string} name - the name for the \"global\" key\n * @param {Scopy~Options} [options] - the options to be used (may be <code>null</code>)\n * @return {string|symbol} The \"global\" key for <code>name</code>.\n * @public\n * @static\n * @memberof Scopy\n */\nScopy.for = function(name, options) {\n  var factory = getKeyFactory(true, options);\n\n  return factory(name);\n};\n\n/**\n * Returns \"global\" keys based on the specified <code>names</code> and using the <code>options</code> provided.\n *\n * If the <code>symbol</code> option is enabled (which it is by default), this method will return <code>names</code>\n * mapped to ES2015 <code>Symbols</code> from the runtime-wide symbol registry (where supported), otherwise\n * <code>names</code> will simply be mapped to themselves prefixed with an underscore.\n *\n * Unlike {@link Scopy.all}, <code>Symbols</code> included in the mapping returned by this method will always be the\n * same when called multiple times with the same name, just like string keys.\n *\n * It is recommended that each name within <code>names</code> be prefixed in order to avoid conflicts with other\n * libraries that may also have a \"global\" key of the same name.\n *\n * This method is ideal when defining keys for protected/internally scoped properties.\n *\n * @example\n * <pre>\n * // user.js\n * var Scopy = require('scopy');\n * var uuid = require('uuid/v4');\n *\n * var keys = Scopy.for.all([ 'example_user_id', 'example_user_lastUpdatedBy' ]);\n * var _name = Scopy('name');\n *\n * function User(name) {\n *   this[keys['example.user.id']] = uuid();\n *   this[keys['example.user.lastUpdatedBy']] = null;\n *   this[_name] = name;\n * }\n *\n * User.prototype.getName = function() {\n *   return this[_name];\n * };\n *\n * module.exports = User;\n *\n * // user-logger.js\n * var EOL = require('os').EOL;\n * var Scopy = require('scopy');\n *\n * var keys = Scopy.for.all([ 'example_user_id', 'example_user_lastUpdatedBy' ]);\n *\n * exports.update = function(output, user) {\n *   var id = user[keys['example.user.id']];\n *   var lastUpdatedBy = user[keys['example.user.lastUpdatedBy']];\n *\n *   output.write('User[' + id + '] has been updated by ' + lastUpdatedBy + EOL);\n * };\n * </pre>\n * @param {string[]} [names] - the names for the \"global\" keys (may be <code>null</code>)\n * @param {Scopy~Options} [options] - the options to be used (may be <code>null</code>)\n * @return {Object.<string, string|symbol>} A mapping containing <code>names</code> and their corresponding \"global\"\n * keys.\n * @public\n * @static\n * @memberof Scopy.for\n */\nScopy.for.all = function(names, options) {\n  names = names || [];\n\n  var factory = getKeyFactory(true, options);\n  var keys = {};\n\n  names.forEach(function(name) {\n    keys[name] = factory(name);\n  });\n\n  return keys;\n};\n\n/**\n * An alias for the {@link Scopy.for.all} method.\n *\n * @param {string[]} [names] - the names for the \"global\" keys (may be <code>null</code>)\n * @param {Scopy~Options} [options] - the options to be used (may be <code>null</code>)\n * @return {Object.<string, string|symbol>} A mapping containing <code>names</code> and their corresponding \"global\"\n * keys.\n * @public\n * @static\n * @memberof Scopy\n */\nScopy.forAll = Scopy.for.all;\n\n/**\n * Returns whether the specified <code>obj</code> represents a scoped or \"global\" key based on the <code>options</code>\n * provided.\n *\n * If the <code>symbol</code> option is enabled (which it is by default), this method will return <code>true</code> if\n * <code>obj</code> is an ES2015 <code>Symbol</code> (where supported), otherwise it will only return <code>true</code>\n * if and only if <code>obj</code> is a string that starts with at least one underscore.\n *\n * @example\n * <pre>\n * var Scopy = require('scopy');\n *\n * Scopy.is(Scopy('foo'));\n * //=> true\n * Scopy.is(Scopy('foo', { symbol: false }));\n * //=> true\n * Scopy.is('foo');\n * //=> false\n * </pre>\n * @param {*} obj - the object to be checked (may be <code>null</code>)\n * @param {Scopy~Options} [options] - the options to be used (may be <code>null</code>)\n * @return {boolean} <code>true</code> if <code>obj</code> is a scoped or \"global\" key; otherwise <code>false</code>.\n * @public\n * @static\n * @memberof Scopy\n */\nScopy.is = function(obj, options) {\n  if (obj == null) {\n    return false;\n  }\n\n  options = parseOptions(options);\n\n  return options.symbol ? typeof obj === 'symbol' : typeof obj === 'string' && obj[0] === '_';\n};\n\n/**\n * Returns the names of all of the specified object's own enumerable properties that are not scoped, in the same order\n * as that provided by a for-in loop.\n *\n * Properties mapped to a <code>Symbol</code> are <b>never</b> included in this method but those mapped to properties\n * whose name is prefixed with an underscore, created when the <code>symbol</code> option has been explicitly disabled,\n * <b>will</b> be included <b>unless</b> the <code>symbol</code> option is explicitly disabled when calling this method.\n *\n * This method is intended to be used just like ES2015's <code>Object.keys</code> method while also supporting cases\n * where <code>Symbols</code> have not been used to scope properties.\n *\n * @example\n * <pre>\n * var Scopy = require('scopy');\n * var uuid = require('uuid/v4');\n *\n * var _generateId = Scopy('generateId');\n * var _id = Scopy('id');\n * var _name = Scopy('name');\n *\n * function User(name) {\n *   this[_id] = this[_generateId]();\n *   this[_name] = name;\n *   this.length = name.length;\n * }\n *\n * User.prototype[_generateId] = function() {\n *   return uuid();\n * };\n *\n * User.prototype.getName = function() {\n *   return this[_name];\n * };\n *\n * Scopy.keys(new User('foo'));\n * //=> [ \"length\" ]\n * Scopy.keys(User.prototype);\n * //=> [ \"getName\" ]\n * </pre>\n * @param {Object} obj - the object whose enumerable own non-scoped property names are to be returned\n * @param {Scopy~Options} [options] - the options to be used (may be <code>null</code>)\n * @return {string[]} An array of strings that represent all of the enumerable non-scoped properties of\n * <code>obj</code>.\n * @public\n * @static\n * @memberof Scopy\n */\nScopy.keys = function(obj, options) {\n  return mapProperties(obj, function(value, name) {\n    return name;\n  }, options);\n};\n\n/**\n * Returns a version of {@link Scopy} that is bound (along with <i>all</i> of its methods) to the specified\n * <code>options</code>.\n *\n * Since it's recommended that consumers use the same options, when specified, this method can be really useful as it\n * allows consumers to only specify the options once. This is especially useful for those wishing to explictly disable\n * the <code>symbol</code> option.\n *\n * Any options passed to the methods within the returned wrapped Scopy API will be ignored in favor of\n * <code>options</code>.\n *\n * @example\n * <pre>\n * var Scopy = require('scopy').using({ symbol: false });\n *\n * Scopy('foo');\n * //=> \"_foo\"\n * Scopy.all([ 'foo', 'bar' ]);\n * //=> { foo: \"_foo\", bar: \"_bar\" }\n * Scopy.is('_foo');\n * //=> true\n * Scopy.is(Symbol('foo'));\n * //=> false\n * </pre>\n * @param {Scopy~Options} [options] - the options to be used (may be <code>null</code>)\n * @return {Function} A version of {@link Scopy} that will, along with its methods, always use <code>options</code>.\n * @public\n * @static\n * @memberof Scopy\n */\nScopy.using = function(options) {\n  options = parseOptions(options);\n\n  var BoundScopy = applyOptions(Scopy, options);\n  applyOptionsToAll(Scopy, BoundScopy, [\n    'all',\n    'entries',\n    'for',\n    'forAll',\n    'is',\n    'keys',\n    'values'\n  ], options);\n\n  BoundScopy.for.all = BoundScopy.forAll;\n  BoundScopy.using = Scopy.using;\n\n  return BoundScopy;\n};\n\n/**\n * Returns the values of all of the specified object's own enumerable properties that are not scoped, in the same order\n * as that provided by a for-in loop.\n *\n * Properties mapped to a <code>Symbol</code> are <b>never</b> included in this method but those mapped to properties\n * whose name is prefixed with an underscore, created when the <code>symbol</code> option has been explicitly disabled,\n * <b>will</b> be included <b>unless</b> the <code>symbol</code> option is explicitly disabled when calling this method.\n *\n * This method is intended to be used just like ES2015's <code>Object.values</code> method while also supporting cases\n * where <code>Symbols</code> have not been used to scope properties.\n *\n * @example\n * <pre>\n * var Scopy = require('scopy');\n * var uuid = require('uuid/v4');\n *\n * var _generateId = Scopy('generateId');\n * var _id = Scopy('id');\n * var _name = Scopy('name');\n *\n * function User(name) {\n *   this[_id] = this[_generateId]();\n *   this[_name] = name;\n *   this.length = name.length;\n * }\n *\n * User.prototype[_generateId] = function() {\n *   return uuid();\n * };\n *\n * User.prototype.getName = function() {\n *   return this[_name];\n * };\n *\n * Scopy.values(new User('foo'));\n * //=> [ 3 ]\n * Scopy.values(User.prototype);\n * //=> [ function() { return this[_name] } ]\n * </pre>\n * @param {Object} obj - the object whose enumerable own non-scoped property values are to be returned\n * @param {Scopy~Options} [options] - the options to be used (may be <code>null</code>)\n * @return {Array} An array containing the values of all of the enumerable non-scoped properties of <code>obj</code>.\n * @public\n * @static\n * @memberof Scopy\n */\nScopy.values = function(obj, options) {\n  return mapProperties(obj, function(value) {\n    return value;\n  }, options);\n};\n\n/**\n * Returns a function that delegates the call to the specified <code>func</code> so that the <code>options</code>\n * provided are always passed to it.\n *\n * The returned function will always return the return value of calling <code>func</code>.\n *\n * @param {Function} func - the function to which <code>options</code> are to be applied\n * @param {Scopy~Options} options - the <code>options</code> to be applied\n * @return {Function} A function which will always pass <code>options</code> as the last argument to <code>func</code>.\n * @private\n */\nfunction applyOptions(func, options) {\n  return function() {\n    var args = Array.prototype.slice.call(arguments, 0, 1);\n\n    return func.apply(null, args.concat(options));\n  };\n}\n\n/**\n * Assigns functions to the specified <code>target</code> for all of the <code>names</code> provided that delegate their\n * calls to the function of the same name on the given <code>source</code> so that the <code>options</code> provided are\n * always passed to them.\n *\n * Each proxy function will always return the return value of calling the original function.\n *\n * @param {Object} source - the object on which the original functions belong\n * @param {Object} target - the object to which the proxy functions are to be assigned\n * @param {string[]} names - the names of each function to be proxied\n * @param {Scopy~Options} options - the <code>options</code> to be used\n * @return {void}\n * @private\n */\nfunction applyOptionsToAll(source, target, names, options) {\n  names.forEach(function(name) {\n    target[name] = applyOptions(source[name], options);\n  });\n}\n\n/**\n * Returns a function which can be used to create scoped/\"global\" keys based on the <code>options</code> provided and a\n * name which is passed to it.\n *\n * @param {boolean} global - <code>true</code> if the keys created by the factory are to be \"global\"; otherwise\n * <code>false</code>\n * @param {?Scopy~Options} options - the options to be used (may be <code>null</code>)\n * @return {Scopy~KeyFactory} The key factory.\n * @private\n */\nfunction getKeyFactory(global, options) {\n  options = parseOptions(options);\n\n  if (options.symbol) {\n    return global ? Symbol.for : Symbol;\n  }\n\n  return function(name) {\n    return '_' + name;\n  };\n}\n\n/**\n * Iterates over all non-scoped properties on the specified <code>object</code> using the <code>options</code> provided\n * and creates a new array containing values derived from the key/value pairs for each property using the given\n * <code>mapper</code>.\n *\n * @param {Object} obj - the object whose non-scoped properties are to be mapped\n * @param {Scopy~PropertyMapper} mapper - the function to be called with the value and name of each non-scoped property\n * and to return a value to be mapped to the result\n * @param {?Scopy~Options} options - the options to be used (may be <code>null/code>)\n * @return {Array} An array containing values derived from the non-scoped properties of <code>obj</code> using\n * <code>mapper</code>.\n * @private\n */\nfunction mapProperties(obj, mapper, options) {\n  options = parseOptions(options);\n\n  var result = [];\n\n  for (var name in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, name) && (options.symbol || name[0] !== '_')) {\n      result.push(mapper(obj[name], name));\n    }\n  }\n\n  return result;\n}\n\n/**\n * Parses the optional input <code>options</code> provided, normalizing options and applying default values, where\n * needed.\n *\n * @param {?Scopy~Options} options - the input options to be parsed (may be <code>null</code> if none were provided)\n * @return {Scopy~Options} A new options object parsed from <code>options</code>.\n * @private\n */\nfunction parseOptions(options) {\n  if (options == null) {\n    options = {};\n  }\n\n  var symbol = options.symbol !== false && typeof Symbol === 'function';\n\n  return { symbol: symbol };\n}\n\nmodule.exports = Scopy;\n\n/**\n * Returns a scoped or \"global\" key based on the specified <code>name</code>.\n *\n * @callback Scopy~KeyFactory\n * @param {string} name - the name on which to base the key\n * @return {string|symbol} The key created for <code>name</code>.\n */\n\n/**\n * The options to be used to create property keys with Scopy.\n *\n * @typedef {Object} Scopy~Options\n * @property {boolean} [symbol=true] - <code>true</code> if ES2015's <code>Symbol</code> should be used, where possible;\n * otherwise <code>false</code>.\n */\n\n/**\n * Returns a single value derived from the non-scoped property <code>name</code> and <code>value</code> provided.\n *\n * @callback Scopy~PropertyMapper\n * @param {*} value - the value of the non-scoped property\n * @param {string} name - the name of the non-scoped property\n * @return {*} The value to mapped for the non-scoped property.\n */\n"],"names":["Scopy","name","options","this","TypeError","getKeyFactory","applyOptions","func","args","Array","prototype","slice","call","arguments","apply","concat","applyOptionsToAll","source","target","names","forEach","global","parseOptions","symbol","Symbol","for","mapProperties","obj","mapper","result","Object","hasOwnProperty","push","all","factory","keys","entries","value","forAll","is","using","BoundScopy","values"],"mappings":";wLA0DA,SAASA,GAAMC,EAAMC,GACnB,GAAIC,eAAgBH,GAClB,KAAM,IAAII,WAAU,6BAKtB,OAFcC,IAAc,EAAOH,GAEpBD,GA0cjB,QAASK,GAAaC,EAAML,GAC1B,MAAO,YACL,GAAIM,GAAOC,MAAMC,UAAUC,MAAMC,KAAKC,UAAW,EAAG,EAEpD,OAAON,GAAKO,MAAM,KAAMN,EAAKO,OAAOb,KAkBxC,QAASc,GAAkBC,EAAQC,EAAQC,EAAOjB,GAChDiB,EAAMC,QAAQ,SAASnB,GACrBiB,EAAOjB,GAAQK,EAAaW,EAAOhB,GAAOC,KAc9C,QAASG,GAAcgB,EAAQnB,GAG7B,MAFAA,GAAUoB,EAAapB,GAEnBA,EAAQqB,OACHF,EAASG,OAAOC,IAAMD,OAGxB,SAASvB,GACd,MAAO,IAAMA,GAiBjB,QAASyB,GAAcC,EAAKC,EAAQ1B,GAClCA,EAAUoB,EAAapB,EAEvB,IAAI2B,KAEJ,KAAK,GAAI5B,KAAQ0B,GACXG,OAAOpB,UAAUqB,eAAenB,KAAKe,EAAK1B,KAAUC,EAAQqB,QAAsB,MAAZtB,EAAK,KAC7E4B,EAAOG,KAAKJ,EAAOD,EAAI1B,GAAOA,GAIlC,OAAO4B,GAWT,QAASP,GAAapB,GAOpB,MANe,OAAXA,IACFA,OAKOqB,OAFIrB,EAAQqB,UAAW,GAA2B,kBAAXC,eAxflDxB,GAAMiC,IAAM,SAASd,EAAOjB,GAC1BiB,EAAQA,KAER,IAAIe,GAAU7B,GAAc,EAAOH,GAC/BiC,IAMJ,OAJAhB,GAAMC,QAAQ,SAASnB,GACrBkC,EAAKlC,GAAQiC,EAAQjC,KAGhBkC,GAqDTnC,EAAMoC,QAAU,SAAST,EAAKzB,GAC5B,MAAOwB,GAAcC,EAAK,SAASU,EAAOpC,GACxC,OAASA,EAAMoC,IACdnC,IAyDLF,EAAMyB,IAAM,SAASxB,EAAMC,GAGzB,MAFcG,IAAc,EAAMH,GAEnBD,IA4DjBD,EAAMyB,IAAIQ,IAAM,SAASd,EAAOjB,GAC9BiB,EAAQA,KAER,IAAIe,GAAU7B,GAAc,EAAMH,GAC9BiC,IAMJ,OAJAhB,GAAMC,QAAQ,SAASnB,GACrBkC,EAAKlC,GAAQiC,EAAQjC,KAGhBkC,GAcTnC,EAAMsC,OAAStC,EAAMyB,IAAIQ,IA4BzBjC,EAAMuC,GAAK,SAASZ,EAAKzB,GACvB,MAAW,OAAPyB,IAIJzB,EAAUoB,EAAapB,GAEhBA,EAAQqB,OAAwB,gBAARI,GAAkC,gBAARA,IAA+B,MAAXA,EAAI,KAkDnF3B,EAAMmC,KAAO,SAASR,EAAKzB,GACzB,MAAOwB,GAAcC,EAAK,SAASU,EAAOpC,GACxC,MAAOA,IACNC,IAiCLF,EAAMwC,MAAQ,SAAStC,GACrBA,EAAUoB,EAAapB,EAEvB,IAAIuC,GAAanC,EAAaN,EAAOE,EAcrC,OAbAc,GAAkBhB,EAAOyC,GACvB,MACA,UACA,MACA,SACA,KACA,OACA,UACCvC,GAEHuC,EAAWhB,IAAIQ,IAAMQ,EAAWH,OAChCG,EAAWD,MAAQxC,EAAMwC,MAElBC,GAiDTzC,EAAM0C,OAAS,SAASf,EAAKzB,GAC3B,MAAOwB,GAAcC,EAAK,SAASU,GACjC,MAAOA,IACNnC,IA6GYF"}